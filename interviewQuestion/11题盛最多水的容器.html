<!--
 * Author       : OBKoro1
 * Date         : 2020-04-15 17:21:59
 * LastEditors  : OBKoro1
 * LastEditTime : 2020-06-30 14:45:26
 * FilePath     : \codeBlack\interviewQuestion\11题盛最多水的容器.html
 * Description  : 11题盛最多水的容器
 * https://github.com/OBKoro1
 -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>11题盛最多水的容器</title>
</head>

<body>
  <script>
    let oldArr = [1, 8, 6, 2, 5, 4, 8, 3, 7]
    // 双指针法
    var maxArea = function (height) {
      let left = 0;//左下标
      let right = height.length - 1;//右下标
      let max = 0;//最大装水量
      while (left < right) {
        let now = (right - left) * Math.min(height[right], height[left]); // 当前水量
        max = now > max ? now : max; // 更新最大水量
        // 窗口缩小思路
        // 从数组左右两侧开始，判定两者的大小，以较小的一侧为滑动边界；
        // 如果滑动边界向内收缩一位的值比之前的值要小，那么继续滑动，这时候的面积肯定是逐渐减小的；
        // 当出现滑动边界的值比之前的大了，那么就需要重新判断下左右边界的大小，进行一次新的操作；
        // 最终会找到一个窗口的最大值 遍历一次 O(n)
        if (height[left] > height[right]) {
          right--;
        } else {
          left++;
        }
      }
      return max;
    };

    // 暴力法
    function maxArea(height) {
      const total = height.length
      let max = 0
      // 双循环 每个木板都跟其他木板匹配一次
      for (const i = 0; i < total; i++) {
        for (const j = 1; j < total; j++) {
          // 两个木板的高度
          const height1 = height[i]
          const height2 = height[j]
          // 获取最小高度
          const heightNum = height1 > height2 ? height2 : height1 // 取木板最小的那个值
          const lengthNum = j - i // 底部的长度
          const size = heightNum * lengthNum // 当前两块木板的面积
          if (size > max) {
            max = size // 最大面积
          }
        }
      }
      return max
    }
    console.log('输出', maxArea(oldArr))
  </script>
</body>

</html>