<!--
 * Author       : OBKoro1
 * Date         : 2020-04-15 17:21:59
 * LastEditors  : OBKoro1
 * LastEditTime : 2020-04-15 17:54:20
 * FilePath     : /codeBlack/算法题/45题跳跃游戏.html
 * Description  : 45题跳跃游戏
 * https://github.com/OBKoro1
 -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>45题跳跃游戏</title>
  </head>
  <body>
    <script>
      let oldArr = [2, 3, 1, 1, 4]
      // let oldArr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1, 0]
      // 递归
      // function jump(nums) {
      //   let num = nums[0] // 初始能跳的步数
      //   if (nums.length === 1) return 0
      //   let total = 0 // 总共跳几次
      //   let everOne = [num] // 每次经过的地方
      //   function jumpOne(newNums, oneNum) {
      //     let maxNum = 0 // 最远能跳多远
      //     let maxIndex = oneNum // 预设最大值
      //     if (oneNum + 1 >= newNums.length) {
      //       // 步数已经足够到达最后一个位置
      //       maxIndex = newNums.length - 1
      //     } else {
      //       // 每个点都跳一遍
      //       for (let i = 1; i <= oneNum; i++) {
      //         // 当前已跳步数大于 之前缓存的最大步数 即为最优解
      //         if (i + newNums[i] >= maxNum) {
      //           maxNum = newNums[i] + i // 最远能跳多远
      //           maxIndex = i // 最远跳的目标位置
      //         }
      //       }
      //     }
      //     total++ // 当前跳跃次数
      //     everOne.push(newNums[maxIndex]) // 每次到达的位置
      //     if (maxIndex !== newNums.length - 1) {
      //       newNums.splice(0, maxIndex) // 清除已跳的元素
      //       jumpOne(newNums, newNums[0])
      //     }
      //   }
      //   jumpOne(nums, num)
      //   return total
      // }
      // 贪心
      var jump = function (nums) {
        var steps = 0
        var canJumpMax = 0 // 下一步的最远距离
        var last_canJumpMax = 0 // 当前循环的最远距离
        var len = nums.length
        for (var i = 0; i < len - 1; i++) {
          canJumpMax = Math.max(canJumpMax, i + nums[i]) // 计算下一步的最远距离
          if (last_canJumpMax == i) {
            last_canJumpMax = canJumpMax // 每次更新为最远距离
            steps++ // 增加步数
          }
          if (last_canJumpMax >= len - 1) { // 步数超出长度 不跳了
            break
          }
        }
        return steps
      }

      console.log('输出', jump(oldArr))
    </script>
  </body>
</html>
