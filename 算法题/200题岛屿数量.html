<!--
 * Author       : OBKoro1
 * Date         : 2020-04-15 17:21:59
 * LastEditors: OBKoro1
 * LastEditTime: 2020-06-08 23:36:55
 * FilePath: /codeBlack/算法题/200题岛屿数量.html
 * Description  : 200题岛屿数量
 * https://github.com/OBKoro1
 -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>200题岛屿数量</title>
  </head>
  <body>
    <script>
      let oldArr = [
        ['1', '1', '1', '1', '0'],
        ['1', '1', '0', '1', '0'],
        ['1', '1', '0', '0', '0'],
        ['0', '0', '0', '0', '0'],
      ]
      let oldArr2 = [
        ['1', '1', '0', '0', '0'],
        ['1', '1', '0', '0', '0'],
        ['0', '0', '1', '0', '0'],
        ['0', '0', '0', '1', '1'],
      ]
      let oldArr3 = [
        ['1', '1', '1'],
        ['0', '1', '0'],
        ['1', '1', '1'],
      ]
      // 深度优先
      var numIslands = function (grid) {
        let num = 0
        if (grid && grid.length) {
          const maxI = grid.length - 1,
            maxJ = grid[0].length - 1
          // 递归将连接的岛屿全都转为海水 连成一片
          function overturn(i, j) {
            if (i < 0 || j < 0 || i > maxI || j > maxJ) return
            if (grid[i][j] === '1') {
              grid[i][j] = '0'
              overturn(i, j - 1)
              overturn(i - 1, j)
              overturn(i + 1, j)
              overturn(i, j + 1)
            }
          }
          for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
              if (grid[i][j] === '1') {
                // 每次碰到1就说明有新的岛屿 与之相连的岛屿都已经递归转化成海水了
                num++
                overturn(i, j) // 将连接的岛屿全都转为海水 连成一片
              }
            }
          }
        }
        return num
      }
      console.log('输出', numIslands(oldArr3))
      console.log('输出', numIslands(oldArr2))
      console.log('输出', numIslands(oldArr))
    </script>
  </body>
</html>
