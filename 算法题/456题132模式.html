<!--
 * Author       : OBKoro1
 * Date         : 2020-04-15 17:21:59
 * LastEditors: OBKoro1
 * LastEditTime: 2020-06-09 23:22:41
 * FilePath: /codeBlack/算法题/456题132模式.html
 * Description  : 456题132模式
 * https://github.com/OBKoro1
 -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>456题132模式</title>
  </head>
  <body>
    <script>
      let oldArr1 = [1, 0, 1, -4, -3]
      let oldArr2 = [3, 5, 0, 3, 4]
      let oldArr3 = [-1, 3, 2, 0]
      // 栈
      var find132pattern = function (nums) {
        if (nums.length <= 2) return false
        const min = [nums[0]]
        const stack = []
        // 数组前i项最小的数字存在一个数组min内
        for (let i = 1; i < nums.length; i++) {
          min[i] = Math.min(min[i - 1], nums[i])
        }
        // 倒序
        for (let i = nums.length - 1; i > 0; i--) {
          // 当前项不是最小值
          if (nums[i] > min[i]) {
            // 栈内数据小于当前值的最小值 从min的大值开始
            while (stack.length !== 0 && stack[stack.length - 1] <= min[i]) {
              stack.pop()
            }
            // 栈内(之前遍历的)数据比当前值小 即满足 l1<l3<l2的需求
            if (stack.length !== 0 && stack[stack.length - 1] < nums[i]) {
              return true
            }
            stack.push(nums[i]) // 比最小值大
          }
        }
        return false
      }
      // // 贪心
      // var find132pattern = function (nums) {
      //   if (nums.length <= 2) return false
      //   let min = nums[0]
      //   for (let i = 1; i < nums.length - 1; i++) {
      //     for (let j = i + 1; j < nums.length; j++) {
      //       // 比主循环大一个索引 当前循环值 比最小值大， 又比主循环值小 即满足
      //       if (nums[j] > min && nums[j] < nums[i]) return true
      //     }
      //     min = Math.min(min, nums[i]) // 遍历过的值的最小值
      //   }
      //   return false
      // }

      console.log('输出', find132pattern(oldArr1))
      console.log('输出', find132pattern(oldArr2))
      console.log('输出', find132pattern(oldArr3))
    </script>
  </body>
</html>
