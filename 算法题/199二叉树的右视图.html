<!--
 * Author       : OBKoro1
 * Date         : 2020-04-15 17:21:59
 * LastEditors  : OBKoro1
 * LastEditTime : 2020-06-30 15:33:54
 * FilePath     : \codeBlack\算法题\199二叉树的右视图.html
 * Description  : 199二叉树的右视图
 * https://github.com/OBKoro1
 -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>199二叉树的右视图</title>
  </head>
  <body>
    <script>
      // https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/shen-du-you-xian-sou-suo-by-shetia-2/
      /**
       * Definition for a binary tree node.
       * function TreeNode(val) {
       *     this.val = val;
       *     this.left = this.right = null;
       * }
       */
      /**
       * @param {TreeNode} root
       * @return {number[]}
       */
      // 深度优先
      var rightSideView = function (root) {
        if (!root) return []
        let res = [] // 结果
        let start = 0 // 树的深度 从0开始
        dfs(root, start, res)
        return res
      }
      function dfs(root, step, res) {
        if (root) {
          if (step === res.length) {
            res.push(root.val) // 数组长度等于树的深度时 添加当前值 因为右侧先遍历 有右侧先添加右侧
          }
          dfs(root.right, step + 1, res)
          dfs(root.left, step + 1, res)
        }
      }
      // 广度优先
      // var rightSideView = function (root) {
      //   if (!root) return []
      //   let queue = [root] // 队列 把树顶加入队列
      //   let arr = [] // 用来存储每层最后个元素值
      //   while (queue.length > 0) {
      //     let len = queue.length // 当前层的广度
      //     while (len) {
      //       let node = queue.shift() // 依次取出当前层队列的元素 从左到右
      //       if (len === 1) arr.push(node.val) // 当是 当前一层的最后一个元素时，把值加入arr
      //       if (node.left) queue.push(node.left) // 先添加左侧的
      //       if (node.right) queue.push(node.right) // 最后添加右侧的 等到最后一个元素时即可添加右侧的值
      //       len--
      //     }
      //   }
      //   return arr
      // }
      console.log('输出', test())
    </script>
  </body>
</html>
